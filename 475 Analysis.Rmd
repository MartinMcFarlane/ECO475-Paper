---
title: "475 Analysis"
output: html_document
date: "2024-01-31"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

# Setup

#load packages
library(quantmod)
library(expss)
library(vtable)
library(xts)
library(tidyr)
library(tidyverse)
library(dplyr)
library(stringi)


```

```{r}
##################################################
## PART A: SETUP & DATA CLEANING                 #
##################################################

# Load primary dataset
housing.raw <- read.csv("Data/housing_indicators_micro.csv")
cols <- c("Census.year..2.", "GEO", "DGUID", "Housing.indicators..9.",
          "Tenure..4.", "VALUE") # cols to keep
housing <- housing.raw[,cols] 
names(housing) <- c("Year", "GEO", "DGUID", "Indicator", "Tenure", "VALUE")

```

```{r}
housing.w <- pivot_wider(housing, id_cols=c("Year", "GEO", "DGUID","Tenure"),
                         names_from="Indicator", values_from="VALUE")
cols <- c("Year", "GEO", "DGUID", "Tenure", "tot.hh", "inadq.pc", "unsuit.pc",
          "unafford.pc", "core.nd", "core.nd.pc", "inadq", "unsuit", "unafford")
names(housing.w) <- cols

housing.w$Tenure[housing.w$Tenure == "Dwelling provided by the local government, First Nation or Indian band"] <- "Government provided"

housing.w$Tenure[housing.w$Tenure == "Total - Tenure"] <- "Total"

# drop government provided tenure values - not relevant
housing.w <- housing.w %>% filter(Tenure!="Government provided")

# replace NAs with zeros
housing.w <- housing.w %>% replace_na(list(tot.hh=0, inadq.pc=0.0, unsuit.pc=0.0, unafford.pc=0.0,
                              core.nd=0, core.nd.pc=0.0, inadq=0, unsuit=0, unafford=0))

# drop subdivisions where tot.hh for total tenure == 0
housing.total <- filter(housing.w, Tenure == "Total" )
# filter df by Tenure == Tenure total
for (i in 1:nrow(housing.total)) {
  if (housing.total[i, "tot.hh"] == 0) {
    yr <- as.numeric(housing.total[i, "Year"]) # if tot.hh == 0, collect year and DGUID
    geo_id <- as.character(housing.total[i, "DGUID"])
    
    # in orig df, drop observation if year and DGUID match
    housing.w <- housing.w %>% subset(!(DGUID==geo_id & Year==yr))
  }
}



```

```{r}
# get summary statistics: group by year-tenure type

vars.of.int <- c("tot.hh", "inadq.pc", "unsuit.pc", "unafford.pc", "inadq",
                 "unsuit", "unafford")

stats <- c("mean(x)", "sd(x)", "min(x)", "median(x)", "max(x)")
stats.label <- c("Mean", "Std. Dev.", "Min", "Median", "Max")

#sumtable(housing.w, vars=vars.of.int, summ=stats, summ.names=stats.label, group="Tenure", out="latex")
```

```{r}
census <- read.csv("C:/Users/marti/Documents/_ECO475 Term Paper/Data/census_2021.csv")
```

```{r}
# Filter Census data to geos, variables of interest

# characteristics/controls of interest
chars_of_int <- c(1,2,3,1403,1526,6,80,81,244,
                  360,1457,1458,1459,1460,
                  1461,1462,1463,1464,2016,2017,
                  2230) 
census.f <- census %>% filter(GEO_LEVEL == "Census subdivision" & CHARACTERISTIC_ID %in% chars_of_int)

# Grab only columns of interest
cols_of_int <- c("DGUID", "GEO_NAME", "CHARACTERISTIC_ID", "CHARACTERISTIC_NAME",
                 "C1_COUNT_TOTAL", "C10_RATE_TOTAL")
census.f <- census.f[,cols_of_int]


# Create value column. If population, use count var. Else, use rate
census.f$VALUE <- NA

for (i in 1:nrow(census.f)) {
if (census.f[i,"CHARACTERISTIC_ID"] %in% c(1,2,3)) {
  census.f[i,"VALUE"] <- census.f[i,"C1_COUNT_TOTAL"]
} else {
  census.f[i,"VALUE"] <- census.f[i,"C10_RATE_TOTAL"]
}
}

```

```{r}
# Convert to wide
## Change characteristic names so they are shorter and more manageable
name.chg <- list(c("Population, 2021", "pop21"),
                 c("Population, 2016", "pop16"),
                 c("Population percentage change, 2016 to 2021", "pop_chg"),
                 c("Population density per square kilometre", "pop_dens"),
                 c("    Married couples", "married"),
                 c("      With children", "marr_w_child"),
                 c("  Median after-tax income of household in 2020 ($)", "med_at_inc"),
                 c("Prevalence of low income based on the Low-income cut-offs, after tax (LICO-AT) (%)", "bel_lico"),
                 c("  Indigenous identity", "indig"),
                 c("  15 to 24 years", "15to24"),
                 c("  25 to 34 years", "25to34"),
                 c("  35 to 44 years", "35to44"),
                 c("  45 to 54 years", "45to54"),
                 c("  55 to 64 years", "55to64"),
                 c("  65 to 74 years", "65to74"),
                 c("  75 to 84 years", "75to84"),
                 c("  85 years and over", "85_plus"),
                 c("  Not Canadian citizens", "non_cdn"),
                 c("  High (secondary) school diploma or equivalency certificate", "he_highshool"),
                 c("  Postsecondary certificate, diploma or degree", "he_postsec"),
                 c("Unemployment rate", "unemp"))

for (name in name.chg) {
  census.f[census.f$CHARACTERISTIC_NAME == name[1], "CHARACTERISTIC_NAME"] <- name[2]
}

## Create wide dataset
census.w <- census.f %>% pivot_wider(id_cols=c("DGUID", "GEO_NAME"),
                         names_from="CHARACTERISTIC_NAME", values_from="VALUE")

# Merge with housing indicator set
full.df <- left_join(housing.w, census.w, by=join_by(DGUID))

```

```{r}
geo_list <- as.data.frame(unique(full.df$GEO_NAME))
```

```{r}
# EXTRA VARIABLES TO CREATE
## Indigenous reserve - if GEO_NAME contains (IRI)
full.df$indig_res = 0
for (i in 1:nrow(full.df)){
  recoded_str <- as.character(full.df[i,"GEO_NAME"]) %>% iconv(from="utf-8", to="ascii")
  sample_s <- str_sub(recoded_str, -6)
  if (grepl("(IRI)", sample_s)) {
    full.df[i,"indig_res"] <- 1
  }
} # the str_sub fcn does not like french accented characters. iconv converted the
  # text to ascii which it did accept without issue. 

## Pop size variables - <500, 500-1000, 1000-5000 etc.? Maybe do histogram of population

## Provinces
### Note: Province codes are a two-character string starting AFTER the first 9 "Fixed width" 
### characters in the DGUID.
provinces <- list(c(10, "NL"),
                  c(11, "PEI"),
                  c(12, "NS"),
                  c(13, "NB"),
                  c(24, "QC"),
                  c(35, "ON"),
                  c(46, "MB"),
                  c(47, "SK"),
                  c(48, "AB"),
                  c(59, "BC"),
                  c(60, "YT"),
                  c(61, "NT"),
                  c(62, "NU"))

full.df$prov <- NA
for (i in 1:nrow(full.df)){
  pr_sub <- as.numeric(substr(full.df[i,"DGUID"], 10, 11))
  for (j in provinces){
    if (pr_sub == j[1]){
      full.df[i,"prov"] <- j[2]
    }
  }
}

## Population Bins

### Going to group as follows based on 2021 pop: 0 to <1000, 1000 to <2500, 
### 2500 to <10000, 10000 to <50000, 50000 to <200000, >=200000

### order: list(var_name, lower_bound, upper_bound)
city_params <- list(
  list("pop_bel_1k", 0, 1000),
  list("pop_1k_2.5k", 1000, 2500),
  list("pop_2.5k_10k", 2500, 10000),
  list("pop_10k_50k", 10000, 50000),
  list("pop_50k_200k", 50000, 200000),
  list("pop_abv_200k", 200000, max(full.df$pop21, na.rm=TRUE) + 1) # max value plus 1 
  ### because will use < for second value. see code below.
)

for (var in city_params){
  col_nam <- as.character(var[1])
  full.df[,col_nam] <- 0
  for (i in 1:nrow(full.df)){
    if(is.na(full.df[i,"pop21"])){
      next
    }
    pop_val <- as.numeric(full.df[i,"pop21"])
    if ((pop_val >= var[2]) & (pop_val < var[3])){
      full.df[i,col_nam] <- 1
    }
  }
}

```


```{r}
##################################################
## PART B: ANALYSIS                              #
##################################################

# How do the housing indicators compare province-by-province? Use pop-based weights
# and equal weight by subdivision to analyze differences?
```

```{r}
# Regression analysis using Tobit model - housing indicators ~ pop size, covar's
```

```{r}

```

```{r}

```


```{r}
### HELPER FUNCTIONS ###
#function encode_dummy(data, new_var, logical) # use logical to code dummy variable new_var = 1


```


```{}
# SCRAP CODE

housing.w <- apply_labels(housing.w,
  tot.hh = "Total Households",
  inadq.pc = "Inadequate Housing (%)",
  inadq = "Inadequate Housing (Count)",
  unsuit.pc = "Unsuitable Housing (%)",
  unsuit = "Unsuitable Housing (Count)",
  unafford.pc = "Unaffordable Housing (%)",
  unafford = "Unaffordable Housing (Count)",
  core.nd.pc = "In Core Housing Need (%)",
  core.nd = "In Core Housing Need (Count)"
)
```

